<!doctype html>
<html lang="sv">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Admin • Kaffekatten TD</title>
  <style>
    html,body{height:100%;margin:0;background:#0f0f10;color:#eee;font-family:system-ui,Segoe UI,Roboto,Arial}
    .wrap{max-width:960px;margin:24px auto;padding:0 14px}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:16px}
    .panel{background:#151515;padding:14px;border-radius:10px}
    input,select,button{padding:8px;border-radius:6px;border:1px solid #333;background:#0b0b0b;color:#fff}
    input,select{width:100%;margin:6px 0}
    button{cursor:pointer;background:#2d6;border:0}
    h2,h3{margin:6px 0 10px 0}
    .row{display:flex;gap:8px;align-items:center}
    .footer{margin-top:18px;display:flex;gap:8px}
    a{color:#8cf}
  </style>
</head>
<body>
  <div class="wrap">
    <h2>Admin • Kaffekatten TD</h2>
    <div class="grid" style="grid-template-columns:1fr 1fr 1fr; gap:16px">
      <div class="panel">
        <h3>Spelinställningar</h3>
        <label>Startpengar</label>
        <input id="adminStartMoney" type="number" value="100" />
        <label>Startliv</label>
        <input id="adminStartLives" type="number" value="10" />
        <label>Max hastighet (1-5)</label>
        <input id="adminMaxSpeed" type="number" value="5" />
        <label>Visa rutnät</label>
        <select id="uiShowGrid"><option value="1">Ja</option><option value="0">Nej</option></select>
        <label>Vägbredd</label>
        <input id="uiPathWidth" type="number" value="24" min="8" max="64" />
          <label>Karta</label>
          <select id="mapPreset"><!-- Options populated by JS --></select>
          <label>Svårighet (1-5)</label>
          <input id="mapDifficulty" type="number" value="1" min="1" max="5" />
          <label><input id="endless" type="checkbox" /> Endless</label>
          <label>Bygg-läge</label>
          <select id="buildMode">
            <option value="paint">Paint</option>
            <option value="single">Single</option>
          </select>
          <label><input id="mute" type="checkbox" /> Mute</label>
        <div class="footer">
          <button id="btnSave">Spara inställningar</button>
          <a href="./SPEL.HTML">Tillbaka till spelet</a>
        </div>
        <div class="footer">
          <button id="btnExportXML">Exportera som XML</button>
          <button id="btnImportXML">Importera XML</button>
          <input id="xmlFile" type="file" accept=".xml,application/xml" style="display:none" />
        </div>
      </div>
      <div class="panel">
        <h3>Torn</h3>
        <div id="towersList" style="display:flex;flex-direction:column;gap:6px"></div>
        <hr>
        <div class="row"><input id="newName" placeholder="namn" /></div>
        <div class="row"><input id="newCost" type="number" placeholder="pris" value="80" /><input id="newRange" type="number" placeholder="räckvidd" value="90" /></div>
        <div class="row"><input id="newDmg" type="number" placeholder="skada" value="8" /><input id="newRate" type="number" placeholder="eldhast (s)" value="1" /></div>
        <div class="row"><input id="newColor" placeholder="#rrggbb" value="#ffb86b" /></div>
        <button id="btnAddTower">Lägg till torn</button>
      </div>
      <div class="panel" id="mapsPanel">
        <h3>Kartor</h3>
        <div id="mapsList" style="display:flex;flex-direction:column;gap:6px"></div>
        <div class="footer">
          <button id="btnNewMap">Ny karta</button>
          <button id="btnRestoreDefaults" style="background:#888">Återställ standardkartor</button>
        </div>
        <div id="mapEditSection" style="margin-top:14px;display:none">
          <h4 id="mapEditTitle">Redigera karta</h4>
          <input id="mapName" placeholder="Namn" style="width:100%;margin-bottom:6px" />
          <textarea id="mapDesc" placeholder="Beskrivning" style="width:100%;min-height:36px;margin-bottom:6px"></textarea>
          <div style="margin-bottom:6px">Redigera väg grafiskt:</div>
          <canvas id="mapCanvas" width="360" height="240" style="background:#222;border-radius:8px;display:block;margin-bottom:8px;touch-action:none;aspect-ratio:3/2"></canvas>
          <div class="row" style="gap:8px">
            <button id="btnSaveMap">Spara karta</button>
            <button id="btnCancelMap" style="background:#888">Avbryt</button>
            <button id="btnDeleteMap" style="background:#b33;display:none">Ta bort</button>
          </div>
          <div class="small" id="mapEditHint" style="margin-top:6px;color:#aaa"></div>
        </div>
      </div>
    </div>
  </div>
  <script src="src/maps.js"></script>
  <script>
    window.onload = function() {
      // --- Robust Map Management UI (file:// compatible) ---
      function get(id) {
        const el = document.getElementById(id);
        if (!el) console.error('Element not found:', id);
        return el;
      }
      const mapsList = get('mapsList');
      const btnNewMap = get('btnNewMap');
      const btnRestoreDefaults = get('btnRestoreDefaults');
      const mapEditSection = get('mapEditSection');
      const mapEditTitle = get('mapEditTitle');
      const mapName = get('mapName');
      const mapDesc = get('mapDesc');
      const mapCanvas = get('mapCanvas');
      const btnSaveMap = get('btnSaveMap');
      const btnCancelMap = get('btnCancelMap');
      const btnDeleteMap = get('btnDeleteMap');
      const mapEditHint = get('mapEditHint');
      let editingMap = null;

      function renderMapsList() {
        try {
          const maps = window.Maps.loadMaps();
          mapsList.innerHTML = '';
          for (const map of maps) {
            const row = document.createElement('div');
            row.className = 'row';
            row.style.justifyContent = 'space-between';
            row.style.alignItems = 'center';
            row.style.gap = '8px';
            row.style.background = map.type === 'default' ? '#181818' : '#232';
            row.style.borderRadius = '6px';
            row.style.padding = '4px 8px';
            row.innerHTML = `<div><strong>${map.name}</strong> <span class="small" style="color:#aaa">(${map.id})</span><br><span class="small">${map.description||''}</span></div>`;
            const right = document.createElement('div');
            const editBtn = document.createElement('button'); editBtn.textContent = 'Redigera';
            editBtn.onclick = () => openMapEditor(map);
            right.appendChild(editBtn);
            if (map.type !== 'default') {
              const delBtn = document.createElement('button'); delBtn.textContent = 'Ta bort'; delBtn.style.background = '#b33';
              delBtn.onclick = () => { if (confirm('Ta bort denna karta?')) { window.Maps.deleteMap(map.id); renderMapsList(); mapEditSection.style.display = 'none'; } };
              right.appendChild(delBtn);
            }
            row.appendChild(right);
            mapsList.appendChild(row);
          }
        } catch (e) { console.error('renderMapsList error', e); }
      }

      // --- Legacy upgrade: scale old 640x480 (PAD 24) coordinate maps to new 1200x800 space ---
      const LEGACY_OLD_W = 640, LEGACY_OLD_H = 480, LEGACY_PAD = 24;
      const GAME_W_NEW = 1200, GAME_H_NEW = 800, PAD_NEW = 24;
      function upgradeLegacyPoints(points){
        if(!Array.isArray(points) || points.length < 2) return { changed:false };
        let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
        for(const p of points){ if(p.x<minX)minX=p.x; if(p.y<minY)minY=p.y; if(p.x>maxX)maxX=p.x; if(p.y>maxY)maxY=p.y; }
        // Heuristic: legacy if it comfortably fits inside old playfield (allow small tolerance) AND not already near new bounds
        const tol=2;
        const legacyRange = (maxX <= LEGACY_OLD_W + tol && maxY <= LEGACY_OLD_H + tol);
        const alreadyNew = (maxX >= GAME_W_NEW - 100 || maxY >= GAME_H_NEW - 100); // rough guard
        if(!legacyRange || alreadyNew) return { changed:false };
        const srcW = LEGACY_OLD_W - 2*LEGACY_PAD;
        const srcH = LEGACY_OLD_H - 2*LEGACY_PAD;
        const dstW = GAME_W_NEW - 2*PAD_NEW;
        const dstH = GAME_H_NEW - 2*PAD_NEW;
        const scaleX = dstW / srcW;
        const scaleY = dstH / srcH; // non-uniform to use full area
        for(const p of points){
          p.x = ((p.x - LEGACY_PAD) * scaleX) + PAD_NEW;
          p.y = ((p.y - LEGACY_PAD) * scaleY) + PAD_NEW;
        }
        return { changed:true, scaleX, scaleY };
      }
      function openMapEditor(map) {
        // Deep clone
        editingMap = JSON.parse(JSON.stringify(map));
        const upg = upgradeLegacyPoints(editingMap.points);
        mapEditSection.style.display = '';
        mapEditTitle.textContent = map.id ? 'Redigera karta' : 'Ny karta';
        mapName.value = editingMap.name || '';
        mapDesc.value = editingMap.description || '';
        btnDeleteMap.style.display = (editingMap.type !== 'default') ? '' : 'none';
        drawMapCanvas();
        mapEditHint.textContent = upg.changed
          ? 'Legacy‑karta uppskalad ('+upg.scaleX.toFixed(2)+'× / '+upg.scaleY.toFixed(2)+'×). Spara för att permanenta.'
          : 'Dra punkter för att flytta, klicka för att lägga till, högerklicka för att ta bort.';
      }
      function closeMapEditor() {
        editingMap = null;
        mapEditSection.style.display = 'none';
      }
      if (btnNewMap) btnNewMap.onclick = () => {
        openMapEditor(window.Maps.createEmptyMap('Ny karta'));
      };
      if (btnRestoreDefaults) btnRestoreDefaults.onclick = () => {
        if (confirm('Återställ alla standardkartor? Egna kartor tas bort.')) {
          window.Maps.restoreDefaults();
          renderMapsList();
          closeMapEditor();
        }
      };
      if (btnCancelMap) btnCancelMap.onclick = closeMapEditor;
      if (btnDeleteMap) btnDeleteMap.onclick = () => {
        if (editingMap && editingMap.id && editingMap.type !== 'default') {
          if (confirm('Ta bort denna karta?')) {
            window.Maps.deleteMap(editingMap.id);
            renderMapsList();
            closeMapEditor();
          }
        }
      };
      if (btnSaveMap) btnSaveMap.onclick = () => {
        if (!editingMap) return;
        if (!editingMap.points || editingMap.points.length < 2) {
          mapEditHint.textContent = 'Du måste lägga till minst två punkter på kartan!';
          mapEditHint.style.color = '#f66';
          return;
        }
        // Bedöm om punkterna redan är i spel-koordinater (inom PAD..GAME_W-PAD)
        let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
        for(const pt of editingMap.points){
          if(pt.x<minX)minX=pt.x; if(pt.y<minY)minY=pt.y; if(pt.x>maxX)maxX=pt.x; if(pt.y>maxY)maxY=pt.y;
        }
    const GAME_W=1200,GAME_H=800,PAD=24;
        const alreadyGame = minX>=PAD-0.5 && maxX<=GAME_W-PAD+0.5 && minY>=PAD-0.5 && maxY<=GAME_H-PAD+0.5;
        if(!alreadyGame){
          // Skala in i spel-ytan med padding
          const srcW = (maxX-minX)||1, srcH=(maxY-minY)||1;
      const scale = Math.min((GAME_W-2*PAD)/srcW, (GAME_H-2*PAD)/srcH);
          editingMap.points = editingMap.points.map(pt=>({
            x: ((pt.x-minX)*scale)+PAD,
            y: ((pt.y-minY)*scale)+PAD
          }));
        }
        editingMap.scaled = true;
        const safeName = mapName.value.trim() || 'Namnlös karta';
        const safeId = safeName.toLowerCase().replace(/[^a-z0-9]+/g, '-');
        editingMap.name = safeName;
        editingMap.id = safeId;
        editingMap.description = mapDesc.value.trim();
        window.Maps.upsertMap(editingMap);
        renderMapsList();
        closeMapEditor();
      };
      // --- Graphical Path Editor ---
      let dragIdx = null;
      let dragOffset = {x:0, y:0};
      // --- Coordinate helpers (keep points in game coords; scale for display) ---
  const GAME_W=1200, GAME_H=800, PAD=24; // storage coordinate space updated to real game canvas
  const EDIT_W=360, EDIT_H=240, EPAD=12; // editor canvas and padding (3:2 aspect)
      const SRC_W = GAME_W-2*PAD, SRC_H = GAME_H-2*PAD;
      const DST_W = EDIT_W-2*EPAD, DST_H = EDIT_H-2*EPAD;
      const EDIT_SCALE = Math.min(DST_W/SRC_W, DST_H/SRC_H);
      function scaleGameToEditor(pt){
        return { x: ((pt.x-PAD)*EDIT_SCALE)+EPAD, y: ((pt.y-PAD)*EDIT_SCALE)+EPAD };
      }
      function editorToGame(x,y){
        return { x: ((x-EPAD)/EDIT_SCALE)+PAD, y: ((y-EPAD)/EDIT_SCALE)+PAD };
      }
      function clampGame(pt){
        pt.x = Math.max(PAD, Math.min(GAME_W-PAD, pt.x));
        pt.y = Math.max(PAD, Math.min(GAME_H-PAD, pt.y));
        return pt;
      }
      function drawMapCanvas() {
        if (!mapCanvas) return;
        const ctx = mapCanvas.getContext('2d');
        ctx.clearRect(0,0,mapCanvas.width,mapCanvas.height);
        if (!editingMap) return;
        // Draw game bounds (PAD) for clarity
        ctx.save();
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 1;
        const padRectX = EPAD - (PAD*EDIT_SCALE - 0); // but since we scale from PAD we can just show inner area
        // Simpler: draw editor working area background subtle (already background) so skip rect
        ctx.restore();
        // Draw path lines
        const pts = editingMap.points;
        if (pts.length) {
          const PATH_W_GAME = 24; // could be dynamic later
          const W = PATH_W_GAME * EDIT_SCALE;
          const innerW = Math.max(6, W*0.55);
          const edgeW = Math.max(4, W*0.08);
          const p0 = scaleGameToEditor(pts[0]);
          // Base
          ctx.save();
          ctx.strokeStyle='#2a2a2a'; ctx.lineCap='round'; ctx.lineWidth=W;
          ctx.beginPath(); ctx.moveTo(p0.x, p0.y);
          for (let i=1;i<pts.length;i++){ const p=scaleGameToEditor(pts[i]); ctx.lineTo(p.x,p.y); }
          ctx.stroke(); ctx.restore();
          // Inner highlight
          ctx.save(); ctx.strokeStyle='rgba(255,255,255,0.08)'; ctx.lineCap='round'; ctx.lineWidth=innerW;
          ctx.beginPath(); ctx.moveTo(p0.x, p0.y);
          for (let i=1;i<pts.length;i++){ const p=scaleGameToEditor(pts[i]); ctx.lineTo(p.x,p.y); }
          ctx.stroke(); ctx.restore();
          // Edge accent
          ctx.save(); ctx.strokeStyle='rgba(0,0,0,0.35)'; ctx.lineCap='round'; ctx.lineWidth=edgeW;
          ctx.beginPath(); ctx.moveTo(p0.x, p0.y);
          for (let i=1;i<pts.length;i++){ const p=scaleGameToEditor(pts[i]); ctx.lineTo(p.x,p.y); }
          ctx.stroke(); ctx.restore();
        }
        // Draw points
        for (let i=0; i<pts.length; i++) {
          const p = scaleGameToEditor(pts[i]);
          ctx.beginPath();
          ctx.arc(p.x, p.y, 7, 0, Math.PI*2);
          ctx.fillStyle = (i===0) ? '#6f6' : (i===pts.length-1 ? '#f66' : '#fff');
          ctx.fill();
          ctx.strokeStyle = '#333';
          ctx.stroke();
        }
      }
      function getMousePos(evt) {
        const rect = mapCanvas.getBoundingClientRect();
        return {
          x: (evt.clientX - rect.left) * (mapCanvas.width / rect.width),
          y: (evt.clientY - rect.top) * (mapCanvas.height / rect.height)
        };
      }
      if (mapCanvas) {
        mapCanvas.addEventListener('pointerdown', e => {
          if (!editingMap) return;
          const pos = getMousePos(e);
            // Check if near an existing point (editor space)
          for (let i=0;i<editingMap.points.length;i++){
            const ed = scaleGameToEditor(editingMap.points[i]);
            if(Math.hypot(ed.x-pos.x, ed.y-pos.y) < 10){
              dragIdx = i;
              const gp = editingMap.points[i];
              const eg = editorToGame(pos.x,pos.y);
              dragOffset = { x: gp.x - eg.x, y: gp.y - eg.y };
              return;
            }
          }
          // Insert a new point after nearest segment (or at end)
          const clickG = editorToGame(pos.x,pos.y);
          let insertIdx = editingMap.points.length;
          let best = Infinity;
          for(let i=0;i<editingMap.points.length-1;i++){
            const a=editingMap.points[i], b=editingMap.points[i+1];
            const dx=b.x-a.x, dy=b.y-a.y; const len2=dx*dx+dy*dy; let t=len2?((clickG.x-a.x)*dx + (clickG.y-a.y)*dy)/len2:0; t=Math.max(0,Math.min(1,t));
            const px=a.x+t*dx, py=a.y+t*dy; const d=Math.hypot(clickG.x-px, clickG.y-py);
            if(d<best){ best=d; insertIdx=i+1; }
          }
          editingMap.points.splice(insertIdx,0, clampGame({x:clickG.x,y:clickG.y}));
          drawMapCanvas();
        });
        mapCanvas.addEventListener('pointermove', e => {
          if (!editingMap || dragIdx === null) return;
          const pos = getMousePos(e);
          const g = editorToGame(pos.x,pos.y);
          editingMap.points[dragIdx] = clampGame({ x: g.x + dragOffset.x, y: g.y + dragOffset.y });
          drawMapCanvas();
        });
        mapCanvas.addEventListener('pointerup', e => { dragIdx = null; });
        mapCanvas.addEventListener('pointerleave', e => { dragIdx = null; });
        mapCanvas.addEventListener('contextmenu', e => {
          e.preventDefault();
          if (!editingMap) return;
          const pos = getMousePos(e);
          // Remove nearest point if close
          let minIdx = -1, minDist = 9999;
          for (let i=0; i<editingMap.points.length; i++) {
            const ed = scaleGameToEditor(editingMap.points[i]);
            const d = Math.hypot(ed.x-pos.x, ed.y-pos.y);
            if (d < minDist) { minDist = d; minIdx = i; }
          }
          if (minDist < 12 && editingMap.points.length > 2) {
            editingMap.points.splice(minIdx, 1);
            drawMapCanvas();
          }
        });
      }
      // Initial render
      renderMapsList();
      console.log('Map admin UI loaded (file:// compatible)');
    };
  </script>
</body>
</html>
