<!doctype html>
<html lang="sv">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Start â€¢ Kaffekatten TD</title>
  <style>
    :root{ --bg:#0f0f10; --panel:#151515; --edge:#2a2a2a; --txt:#eee; --muted:#bbb; --btn:#2d6; --btn2:#244; }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--txt);font-family:system-ui,Segoe UI,Roboto,Arial}
  .wrap{max-width:960px;margin:40px auto;padding:0 16px}
    .hdr{display:flex;justify-content:space-between;align-items:center;margin-bottom:14px}
    .title{font-weight:700;font-size:22px}
  .card{background:var(--panel);border:1px solid var(--edge);border-radius:14px;padding:16px;box-shadow:0 2px 10px rgba(0,0,0,0.25)}
    label{display:block;margin:10px 0 4px;color:#ccc}
    input,select,button{width:100%;padding:10px;border-radius:10px;border:1px solid #333;background:#0b0b0b;color:#fff}
    button,.btn{cursor:pointer;background:var(--btn);border:0;margin-top:12px;display:inline-block;text-align:center;text-decoration:none}
  .grid{display:grid;grid-template-columns:2fr 1fr;gap:16px}
  @media (max-width: 900px){ .grid{ grid-template-columns: 1fr; } }
    .row{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    .links{display:flex;gap:10px;margin-top:12px}
    .row-btns{display:flex;gap:8px;margin-top:8px;flex-wrap:wrap}
    a{color:#8cf}
  .preview{background:#0b0b0c;border:1px solid #333;border-radius:12px;padding:10px;box-shadow:inset 0 1px 0 rgba(255,255,255,0.04)}
    .small{color:var(--muted);font-size:12px}
    canvas{image-rendering:pixelated}
  </style>
drawPreview();
  <script src="src/maps.js"></script>
  <script>
    window.onload = function() {
      function qs(s){ return document.querySelector(s); }
      var mapPreset = qs('#mapPreset');
      var difficulty = qs('#difficulty');
      var endless = qs('#endless');
      var buildMode = qs('#buildMode');
      var prev = document.getElementById('mapPrev');
      var pctx = prev.getContext('2d');
      var cbHC = document.getElementById('colorblind');
      var cbRM = document.getElementById('reducedMotion');

      // --- Helper: generate points for default maps if missing ---
      function generateLegacyPoints(id, width, height) {
        var TILE = 32;
        var COLS = Math.max(3, Math.floor(width/TILE));
        var ROWS = Math.max(3, Math.floor(height/TILE));
        var cx = function(col){ return col*TILE+TILE/2; }, cy = function(row){ return row*TILE+TILE/2; };
        var path = [];
        if(id==='ring'){
          for(var i=0;i<COLS;i++) path.push({x:cx(i),y:cy(1)});
          for(var r=2;r<ROWS-2;r++) path.push({x:cx(COLS-1),y:cy(r)});
          for(var i=COLS-1;i>=0;i--) path.push({x:cx(i),y:cy(ROWS-2)});
        } else if(id==='maze'){
          for(var i=1;i<COLS-1;i++) path.push({x:cx(i),y:cy(1)});
          for(var r=2;r<ROWS-2;r++) path.push({x:cx(COLS-2),y:cy(r)});
          for(var i=COLS-2;i>1;i--) path.push({x:cx(i),y:cy(ROWS-3)});
          for(var r=ROWS-4;r>1;r--) path.push({x:cx(2),y:cy(r)});
        }
        return path;
      }

      // Populate map dropdown from localStorage, always include default maps
      function populateMapDropdown() {
        var maps = [];
        // Always start with defaults, then merge in custom
        var defaults = (window.Maps && window.Maps.DEFAULT_MAPS) ? window.Maps.DEFAULT_MAPS.map(function(m){ return Object.assign({}, m); }) : [];
        // Generate points for defaults if missing
        for(var i=0;i<defaults.length;i++){
          if(!Array.isArray(defaults[i].points) || defaults[i].points.length < 2){
            defaults[i].points = generateLegacyPoints(defaults[i].id, prev.width, prev.height);
          }
        }
        // Load custom maps
        var stored = (window.Maps && window.Maps.loadMaps) ? window.Maps.loadMaps() : [];
        // Remove any default maps from stored (by id)
        var customs = stored.filter(function(m){ return !defaults.some(function(d){ return d.id === m.id; }); });
        maps = defaults.concat(customs);
        mapPreset.innerHTML = '';
        for (var i=0; i<maps.length; i++) {
          var map = maps[i];
          var opt = document.createElement('option');
          opt.value = map.id;
          opt.textContent = map.name + (map.type === 'default' ? '' : ' (egen)');
          mapPreset.appendChild(opt);
        }
        // Set value to last used or first
        var KEY = 'td-settings-v1';
        var data = {};
        try { data = JSON.parse(localStorage.getItem(KEY)||'{}')||{}; } catch(e){ data={}; }
        var MapSettings = data.MapSettings || {};
        var sel = MapSettings.preset || '';
        if (!maps.some(function(m){ return m.id === sel; })) sel = maps[0] ? maps[0].id : '';
        mapPreset.value = sel;
      }
      populateMapDropdown();

      // Set other fields from localStorage if available
      var KEY = 'td-settings-v1';
      var data = {};
      try { data = JSON.parse(localStorage.getItem(KEY)||'{}')||{}; } catch(e){ data={}; }
      var MapSettings = data.MapSettings || {};
      var Settings = data.Settings || {};
      difficulty.value = String(MapSettings.difficulty||1);
      endless.checked = !!MapSettings.endless;
      buildMode.value = Settings.buildMode||'paint';

      // --- Unified scaling: scale from new game space (1200x800, PAD=24) to preview canvas (480x300) ---
      function scaleGameToPreview(pt) {
        const GAME_W=1200, GAME_H=800, PAD=24;
        const PREV_W=480, PREV_H=300, PPAD=12; // keep existing preview size/aspect
        const srcW = GAME_W-2*PAD, srcH = GAME_H-2*PAD;
        const dstW = PREV_W-2*PPAD, dstH = PREV_H-2*PPAD;
        const scale = Math.min(dstW/srcW, dstH/srcH);
        return {
          x: ((pt.x-PAD)*scale)+PPAD,
          y: ((pt.y-PAD)*scale)+PPAD
        };
      }
      function drawPreview(){
        // Use the same map list as dropdown
        var maps = [];
        var defaults = (window.Maps && window.Maps.DEFAULT_MAPS) ? window.Maps.DEFAULT_MAPS.map(function(m){ return Object.assign({}, m); }) : [];
        for(var i=0;i<defaults.length;i++){
          if(!Array.isArray(defaults[i].points) || defaults[i].points.length < 2){
            defaults[i].points = generateLegacyPoints(defaults[i].id, prev.width, prev.height);
          }
        }
        var stored = (window.Maps && window.Maps.loadMaps) ? window.Maps.loadMaps() : [];
        var customs = stored.filter(function(m){ return !defaults.some(function(d){ return d.id === m.id; }); });
        maps = defaults.concat(customs);
        var map = maps.find(function(m){ return m.id === mapPreset.value; });
        if (!map || !Array.isArray(map.points) || map.points.length < 2) {
          pctx.clearRect(0,0,prev.width,prev.height);
          return;
        }
        var tmp = document.createElement('canvas'); tmp.width=prev.width; tmp.height=prev.height; var tctx=tmp.getContext('2d');
        tctx.clearRect(0,0,tmp.width,tmp.height);
        tctx.fillStyle='#0b0b0c'; tctx.fillRect(0,0,tmp.width,tmp.height);
        var path = map.points;
        if(path.length>1){
          var hc = !!cbHC?.checked;
          // Draw path lines with scaling
          tctx.strokeStyle=hc?'#3a3a3a':'#2a2a2a'; tctx.lineWidth=18; tctx.lineCap='round'; tctx.beginPath();
          var p0 = scaleGameToPreview(path[0]);
          tctx.moveTo(p0.x, p0.y);
          for(var i=1;i<path.length;i++){
            var p = scaleGameToPreview(path[i]);
            tctx.lineTo(p.x, p.y);
          }
          tctx.stroke();
          tctx.strokeStyle=hc?'rgba(255,255,255,0.12)':'rgba(255,255,255,0.08)'; tctx.lineWidth=10; tctx.beginPath();
          p0 = scaleGameToPreview(path[0]);
          tctx.moveTo(p0.x, p0.y);
          for(var i=1;i<path.length;i++){
            var p = scaleGameToPreview(path[i]);
            tctx.lineTo(p.x, p.y);
          }
          tctx.stroke();
          // Start/Goal markers
          var start=scaleGameToPreview(path[0]), goal=scaleGameToPreview(path[path.length-1]), r=12;
          // Start
          tctx.beginPath(); tctx.arc(start.x,start.y,r,0,Math.PI*2); tctx.fillStyle=(cbHC?.checked?'#00c853':'#1e8e3e'); tctx.fill(); tctx.lineWidth=3; tctx.strokeStyle='#fff'; tctx.stroke();
          tctx.fillStyle='#fff'; tctx.font='12px system-ui'; tctx.textAlign='center'; tctx.textBaseline='middle'; tctx.fillText('S', start.x, start.y+1);
          // Goal
          tctx.lineWidth=3; tctx.strokeStyle='#fff'; tctx.beginPath(); tctx.arc(goal.x,goal.y,r+4,0,Math.PI*2); tctx.stroke();
          tctx.strokeStyle=(cbHC?.checked?'#ffab00':'#c5221f'); tctx.beginPath(); tctx.arc(goal.x,goal.y,r,0,Math.PI*2); tctx.stroke(); tctx.beginPath(); tctx.arc(goal.x,goal.y,Math.max(5,Math.floor(r*0.5)),0,Math.PI*2); tctx.fillStyle=(cbHC?.checked?'#ffab00':'#c5221f'); tctx.fill();
        }
        pctx.clearRect(0,0,prev.width,prev.height); pctx.drawImage(tmp,0,0);
      }
      drawPreview();
      mapPreset.addEventListener('change', function(){
        // Save selected map to localStorage for next reload
        var KEY = 'td-settings-v1';
        var data = {};
        try { data = JSON.parse(localStorage.getItem(KEY)||'{}')||{}; } catch(e){ data={}; }
        data.MapSettings = data.MapSettings || {};
        data.MapSettings.preset = mapPreset.value;
        localStorage.setItem(KEY, JSON.stringify(data));
        drawPreview();
      });
      cbHC && cbHC.addEventListener('change', drawPreview);
    };
  </script>
  <script>
    // Non-module fallback: draw a simple map preview inline (works over file://)
    (function(){
      // Fallback mapping for file:// users: map new presets to legacy ones if needed
      var PRESET_MAP = {
        twinLanes: 'zigzag',
        forkMerge: 'maze',
        overpass8: 'figure8',
        spiralCore: 'riverMeander',
        switchbacks: 'zigzag',
        islands: 'riverMeander',
        portals: 'figure8',
        pockets: 'maze'
      };
      function bind(){
        const c = document.getElementById('mapPrev'); if(!c) return; const ctx=c.getContext('2d');
        const sel = document.getElementById('mapPreset');
        const cbHC = document.getElementById('colorblind');
      const TILE=32; // fits the 480x300 preview well
      function buildPath(preset){
        // Fallback mapping for file:// users: map new presets to legacy ones if needed
        var PRESET_MAP = {
          twinLanes: 'zigzag',
          forkMerge: 'maze',
          overpass8: 'figure8',
          spiralCore: 'riverMeander',
          switchbacks: 'zigzag',
          islands: 'riverMeander',
          portals: 'figure8',
          pockets: 'maze'
        };
        if(PRESET_MAP[preset]) preset = PRESET_MAP[preset];
        const path=[]; const COLS=Math.max(3, Math.floor(c.width/TILE)); const ROWS=Math.max(3, Math.floor(c.height/TILE));
        const cx=(col)=>col*TILE+TILE/2, cy=(row)=>row*TILE+TILE/2;
  if(preset==='maze'){
          for(let i=1;i<COLS-1;i++) path.push({x:cx(i),y:cy(1)});
          for(let r=2;r<ROWS-2;r++) path.push({x:cx(COLS-2),y:cy(r)});
          for(let i=COLS-2;i>1;i--) path.push({x:cx(i),y:cy(ROWS-3)});
          for(let r=ROWS-4;r>1;r--) path.push({x:cx(2),y:cy(r)});
        } else if(preset==='figure8'){
          for(let i=1;i<COLS-1;i++) path.push({x:cx(i),y:cy(1)});
          for(let r=2;r<Math.floor(ROWS/2);r++) path.push({x:cx(COLS-2),y:cy(r)});
          for(let i=COLS-2;i>1;i--) path.push({x:cx(i),y:cy(Math.floor(ROWS/2))});
          for(let r=Math.floor(ROWS/2)+1;r<ROWS-2;r++) path.push({x:cx(2),y:cy(r)});
          for(let i=2;i<COLS-1;i++) path.push({x:cx(i),y:cy(ROWS-2)});
        } else if(preset==='zigzag'){
          let ltr=true;
          for(let r=1;r<ROWS-1;r++){
            if(ltr){ for(let c2=1;c2<COLS-1;c2++) path.push({x:cx(c2),y:cy(r)}); }
            else { for(let c2=COLS-2;c2>0;c2--) path.push({x:cx(c2),y:cy(r)}); }
            if(r<ROWS-2){ const last=path[path.length-1]; path.push({x:last.x, y:cy(r+1)}); }
            ltr=!ltr;
          }
        } else if(preset==='river' || preset==='spiral'){
          const samples=140; const midY=c.height/2; const amp=Math.max(TILE*2, c.height*0.32);
          for(let i=0;i<=samples;i++){
            const t=i/samples; const x=t*c.width; const y=midY + Math.sin(t*Math.PI*2.2)*amp*0.8 + Math.sin(t*Math.PI*5.4)*amp*0.2; path.push({x,y});
          }
        } else if(preset==='riverWide'){
          const samples=160, midY=c.height/2, amp=Math.max(TILE*2, c.height*0.42);
          for(let i=0;i<=samples;i++){ const t=i/samples; const x=t*c.width; const y=midY + Math.sin(t*Math.PI*1.9)*amp; path.push({x,y}); }
        } else if(preset==='riverTight'){
          const samples=180, midY=c.height/2, amp=Math.max(TILE*2, c.height*0.25);
          for(let i=0;i<=samples;i++){ const t=i/samples; const x=t*c.width; const y=midY + Math.sin(t*Math.PI*3.0)*amp*0.85 + Math.sin(t*Math.PI*6.0)*amp*0.18; path.push({x,y}); }
        } else if(preset==='riverMeander'){
          const samples=200, midY=c.height/2, amp=Math.max(TILE*2, c.height*0.36);
          for(let i=0;i<=samples;i++){ const t=i/samples; const x=t*c.width; const y=midY + Math.sin(t*Math.PI*1.6)*amp*0.9 + Math.sin(t*Math.PI*4.0)*amp*0.28; path.push({x,y}); }
        } else if(preset==='riverBraided'){
          const samples=200, midY=c.height/2, amp=Math.max(TILE*2, c.height*0.34);
          for(let i=0;i<=samples;i++){ const t=i/samples; const x=t*c.width; const y=midY + Math.sin(t*Math.PI*2.0)*amp*0.85 + Math.sin(t*Math.PI*3.2 + Math.PI/3)*amp*0.25; path.push({x,y}); }
        } else if(preset==='riverDelta'){
          const samples=200, midY=c.height/2, amp=Math.max(TILE*2, c.height*0.36);
          for(let i=0;i<=samples;i++){ const t=i/samples; const x=t*c.width; const y=midY + Math.sin(t*Math.PI*1.8)*amp*0.65 + Math.sin(t*Math.PI*4.2)*amp*0.18; path.push({x,y}); }
        } else if(preset==='random'){
          const pts=[]; const count=10;
          pts.push({x:TILE*0.75,y:c.height*0.25+Math.random()*c.height*0.5});
          for(let i=0;i<count;i++) pts.push({x:Math.random()*c.width, y:TILE*0.75+Math.random()*(c.height-TILE*1.5)});
          pts.push({x:c.width-TILE*0.75,y:c.height*0.25+Math.random()*c.height*0.5});
          pts.sort((a,b)=>a.x-b.x); pts.forEach(p=>path.push(p));
        } else if(preset==='clover'){
          // four lobes around center
          const midC=Math.floor(COLS/2), midR=Math.floor(ROWS/2);
          const r=3; const loop=(ox,oy)=>{
            for(let a=0;a<Math.PI*2;a+=Math.PI/6){ const x=midC+ox+Math.round(Math.cos(a)*r); const y=midR+oy+Math.round(Math.sin(a)*r); path.push({x:cx(x),y:cy(y)}); }
          };
          loop(-4,0); loop(4,0); loop(0,-3); loop(0,3);
        } else if(preset==='stadium'){
          // oval around edges with soft corners
          const L=1,R=COLS-2,T=1,B=ROWS-2;
          for(let c=L;c<=R;c++) path.push({x:cx(c),y:cy(T)});
          for(let r=T+1;r<=B;r++) path.push({x:cx(R),y:cy(r)});
          for(let c=R-1;c>=L;c--) path.push({x:cx(c),y:cy(B)});
          for(let r=B-1;r>=T;r--) path.push({x:cx(L),y:cy(r)});
        } else if(preset==='twinLanes'){
          const midR=Math.floor(ROWS/2); const top=Math.max(1, midR-3), bot=Math.min(ROWS-2, midR+3);
          for(let c2=1;c2<COLS-2;c2++) path.push({x:cx(c2),y:cy(top)});
          for(let r=top;r<=bot;r++) path.push({x:cx(COLS-2),y:cy(r)});
          for(let c2=COLS-2;c2>=3;c2--) path.push({x:cx(c2),y:cy(bot)});
          for(let c2=3;c2<COLS-1;c2++){
            const t=(c2-3)/Math.max(1,(COLS-1-3));
            const y=Math.round(bot + (midR-bot)*t);
            path.push({x:cx(c2), y:cy(Math.max(1, Math.min(ROWS-2,y))) });
          }
        } else if(preset==='forkMerge'){
          const midC=Math.floor(COLS/2), midR=Math.floor(ROWS/2);
          for(let c2=1;c2<=midC-1;c2++) path.push({x:cx(c2), y:cy(midR)});
          for(let r=midR-1;r>=2;r--) path.push({x:cx(midC-1), y:cy(r)});
          for(let c2=midC-1;c2<=midC+1;c2++) path.push({x:cx(c2), y:cy(2)});
          for(let r=2;r<=midR;r++) path.push({x:cx(midC+1), y:cy(r)});
          for(let r=midR+1;r<=ROWS-3;r++) path.push({x:cx(midC+1), y:cy(r)});
          for(let c2=midC+1;c2>=midC-1;c2--) path.push({x:cx(c2), y:cy(ROWS-3)});
          for(let r=ROWS-3;r>=midR;r--) path.push({x:cx(midC-1), y:cy(r)});
          for(let c2=midC-1;c2<COLS-1;c2++) path.push({x:cx(c2), y:cy(midR)});
        } else if(preset==='overpass8'){
          const midR=Math.floor(ROWS/2), midC=Math.floor(COLS/2), off=3;
          for(let c2=2;c2<COLS-2;c2++) path.push({x:cx(c2), y:cy(midR-off)});
          for(let r=midR-off;r<=midR-1;r++) path.push({x:cx(COLS-2), y:cy(r)});
          for(let c2=COLS-2;c2>=2;c2--) path.push({x:cx(c2), y:cy(midR-1)});
          for(let r=midR-1;r>=midR-off;r--) path.push({x:cx(2), y:cy(r)});
          for(let r=midR-off;r<=midR+off;r++) path.push({x:cx(midC), y:cy(r)});
          for(let c2=2;c2<COLS-2;c2++) path.push({x:cx(c2), y:cy(midR+off)});
          for(let r=midR+off;r<=midR+off+2;r++) path.push({x:cx(COLS-2), y:cy(r)});
          for(let c2=COLS-2;c2>=2;c2--) path.push({x:cx(c2), y:cy(midR+off+2)});
          for(let r=midR+off+2;r>=midR+off;r--) path.push({x:cx(2), y:cy(r)});
          for(let r=midR+off;r>=midR;r--) path.push({x:cx(midC+1), y:cy(r)});
          for(let c2=midC+1;c2<COLS-1;c2++) path.push({x:cx(c2), y:cy(midR)});
        } else if(preset==='spiralCore'){
          const cxp=c.width/2, cyp=c.height/2, maxR=Math.min(c.width,c.height)*0.42; const turns=2.3; const steps=140;
          for(let i=0;i<=steps;i++){ const t=i/steps; const ang=t*Math.PI*2*turns; const r=maxR*(1-t*0.85); const x=cxp+Math.cos(ang)*r; const y=cyp+Math.sin(ang)*r; path.push({x,y}); }
          const last=path[path.length-1]; for(let x=last.x; x<=c.width-24; x+=18){ path.push({x, y:last.y}); }
        } else if(preset==='switchbacks'){
          const stepR=2; let rr=2; let ltr=true;
          while(rr<=ROWS-3){ if(ltr){ for(let c2=1;c2<COLS-1;c2++) path.push({x:cx(c2), y:cy(rr)}); } else { for(let c2=COLS-2;c2>=1;c2--) path.push({x:cx(c2), y:cy(rr)}); } const r2=Math.min(ROWS-3, rr+stepR); for(let r=rr;r<=r2;r++) path.push({x:cx(ltr?COLS-2:1), y:cy(r)}); rr=r2+1; ltr=!ltr; }
        } else if(preset==='islands'){
          const samples=180, midY=c.height/2, amp=Math.max(TILE*2, c.height*0.34);
          for(let i=0;i<=samples;i++){ const t=i/samples; const x=t*c.width; const y=midY + Math.sin(t*Math.PI*1.9)*amp*0.85 + Math.sin(t*Math.PI*3.2)*amp*0.25; path.push({x,y}); }
        } else if(preset==='portals'){
          const midC=Math.floor(COLS/2), midR=Math.floor(ROWS/2);
          for(let c2=1;c2<=midC;c2++) path.push({x:cx(c2), y:cy(midR)});
          const rad=3; for(let a=0;a<=Math.PI*2;a+=Math.PI/10){ path.push({x: cx(midC)+Math.cos(a)*rad*TILE, y: cy(midR)+Math.sin(a)*rad*TILE }); }
          for(let c2=midC+1;c2<COLS-2;c2++){ const t=(c2-(midC+1))/(COLS-(midC+1)); const y=Math.round(midR + (2-midR)*t); path.push({x:cx(c2), y:cy(Math.max(1,Math.min(ROWS-2,y))) }); }
          for(let c2=COLS-2;c2<COLS-1;c2++) path.push({x:cx(c2), y:cy(3)});
        } else if(preset==='pockets'){
          const cxp=c.width/2, cyp=c.height/2; const rx=Math.max(80, c.width*0.38), ry=Math.max(60, c.height*0.28);
          const laps=3, steps=80; for(let lap=0; lap<laps; lap++){ const shrink=1-lap*0.18; for(let i=0;i<=steps;i++){ const t=i/steps*Math.PI*2; const x=cxp+Math.cos(t)*rx*shrink; const y=cyp+Math.sin(t)*ry*shrink; path.push({x,y}); } for(let k=0;k<4;k++) path.push({x: cxp + k*4, y: cyp + k*3 }); }
        } else {
          // ring
          for(let i=0;i<COLS;i++) path.push({x:cx(i),y:cy(1)});
          for(let r=2;r<ROWS-2;r++) path.push({x:cx(COLS-1),y:cy(r)});
          for(let i=COLS-1;i>=0;i--) path.push({x:cx(i),y:cy(ROWS-2)});
        }
        return path;
      }
    function draw(){
        const preset = (sel && sel.value) || 'ring';
        const path = buildPath(preset);
        ctx.clearRect(0,0,c.width,c.height);
        ctx.fillStyle='#0b0b0c'; ctx.fillRect(0,0,c.width,c.height);
        if(path.length>1){
      const hc = !!cbHC?.checked;
      ctx.strokeStyle=hc?'#3a3a3a':'#2a2a2a'; ctx.lineWidth=18; ctx.lineCap='round'; ctx.beginPath(); ctx.moveTo(path[0].x,path[0].y); for(const p of path){ ctx.lineTo(p.x,p.y); } ctx.stroke();
      ctx.strokeStyle=hc?'rgba(255,255,255,0.12)':'rgba(255,255,255,0.08)'; ctx.lineWidth=10; ctx.beginPath(); ctx.moveTo(path[0].x,path[0].y); for(const p of path){ ctx.lineTo(p.x,p.y); } ctx.stroke();
          // Start/Goal markers
          const start=path[0], goal=path[path.length-1]; const r=12;
      ctx.beginPath(); ctx.arc(start.x,start.y,r,0,Math.PI*2); ctx.fillStyle=(hc?'#00c853':'#1e8e3e'); ctx.fill(); ctx.lineWidth=3; ctx.strokeStyle='#fff'; ctx.stroke();
          ctx.fillStyle='#fff'; ctx.font='12px system-ui'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText('S', start.x, start.y+1);
          ctx.lineWidth=3; ctx.strokeStyle='#fff'; ctx.beginPath(); ctx.arc(goal.x,goal.y,r+4,0,Math.PI*2); ctx.stroke();
      ctx.strokeStyle=(hc?'#ffab00':'#c5221f'); ctx.beginPath(); ctx.arc(goal.x,goal.y,r,0,Math.PI*2); ctx.stroke(); ctx.beginPath(); ctx.arc(goal.x,goal.y,Math.max(5,Math.floor(r*0.5)),0,Math.PI*2); ctx.fillStyle=(hc?'#ffab00':'#c5221f'); ctx.fill();
        }
      }
      // If the module didn't draw anything, render fallback preview
      function maybeDraw(){ try{ const a=ctx.getImageData(0,0,1,1).data[3]; if(a===0) draw(); }catch(e){ draw(); } }
      setTimeout(maybeDraw, 300);
  sel && sel.addEventListener('change', draw);
  cbHC && cbHC.addEventListener('change', draw);
      window.addEventListener('resize', draw);
      }
      if(document.readyState==='loading') document.addEventListener('DOMContentLoaded', bind); else bind();
    })();
  </script>
  <script>
    // Fallback: bind Start after DOM is ready (works over file:// even without modules)
    (function(){
      const qs = s=>document.querySelector(s);
  function bind(){
        const btn = qs('#btnStart');
        if(!btn) return;
        btn.addEventListener('click', (ev)=>{
          try{ ev.preventDefault(); }catch(_e){}
          try{
            const mapPreset = qs('#mapPreset')?.value || 'ring';
            const PRESET_MAP = {
              twinLanes: 'zigzag',
              forkMerge: 'maze',
              overpass8: 'figure8',
              spiralCore: 'riverMeander',
              switchbacks: 'zigzag',
              islands: 'riverMeander',
              portals: 'figure8',
              pockets: 'maze'
            };
            const mapped = PRESET_MAP[mapPreset] || mapPreset;
            const diff = Math.max(1, Math.min(5, parseInt(qs('#difficulty')?.value)||1));
            const endless = !!qs('#endless')?.checked;
            const buildMode = qs('#buildMode')?.value || 'paint';
            const colorblind = !!qs('#colorblind')?.checked;
            const reducedMotion = !!qs('#reducedMotion')?.checked;
            const KEY='td-settings-v1';
            let data={};
            try{ data = JSON.parse(localStorage.getItem(KEY)||'{}')||{}; }catch(err){ data={}; }
            data.Settings = { ...(data.Settings||{}), buildMode, maxSpeed: (data.Settings && data.Settings.maxSpeed) || 5 };
            data.MapSettings = { ...(data.MapSettings||{}), preset: mapped, difficulty: diff, endless };
            data.Visuals = { ...(data.Visuals||{}), colorblindMode: colorblind, reducedMotion, theme: (data.Visuals && data.Visuals.theme) || 'dim' };
            data.ts = Date.now();
            localStorage.setItem(KEY, JSON.stringify(data));
          }catch(err){ /* ignore and still navigate */ }
          location.href = './SPEL.HTML';
        });
      }
      if(document.readyState === 'loading') document.addEventListener('DOMContentLoaded', bind); else bind();
    })();
  </script>
  <script>
    // START: XML import/export (file:// friendly)
    (function(){
      const KEY='td-settings-v1';
      function ensure(d){ d=d||{}; d.Admin=d.Admin||{startMoney:100,startLives:10,upgCost:{dmg:30,range:25,rate:35}}; d.Settings=d.Settings||{maxSpeed:5,buildMode:'paint'}; d.Visuals=d.Visuals||{showGrid:true,pathWidth:24}; d.MapSettings=d.MapSettings||{preset:'ring',difficulty:1,endless:false}; d.Audio=d.Audio||{muted:true}; d.TOWER_TYPES=d.TOWER_TYPES||{}; return d; }
      function esc(s){ return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/\"/g,'&quot;'); }
      function toXML(d){ d=ensure(d); const t=Object.keys(d.TOWER_TYPES).map(id=>{const def=d.TOWER_TYPES[id]; return `    <Tower id="${esc(def.id||id)}" label="${esc(def.label||id)}" cost="${def.cost||50}" range="${def.range||80}" dmg="${def.dmg||5}" fireRate="${def.fireRate||1}" color="${esc(def.color||'#ccc')}" sellFactor="${def.sellFactor==null?0.7:def.sellFactor}"${def.aoe?` aoe="${def.aoe}"`:''}${def.slow?` slow="${def.slow}"`:''}${def.slowTime?` slowTime="${def.slowTime}"`:''} />`;}).join('\n'); return `<?xml version="1.0" encoding="UTF-8"?>\n<kaffekatten>\n  <Admin startMoney="${d.Admin.startMoney}" startLives="${d.Admin.startLives}">\n    <upgCost dmg="${d.Admin.upgCost.dmg}" range="${d.Admin.upgCost.range}" rate="${d.Admin.upgCost.rate}" />\n  </Admin>\n  <Settings maxSpeed="${d.Settings.maxSpeed}" buildMode="${esc(d.Settings.buildMode)}" />\n  <Visuals showGrid="${!!d.Visuals.showGrid}" pathWidth="${d.Visuals.pathWidth}" />\n  <Map preset="${esc(d.MapSettings.preset)}" difficulty="${d.MapSettings.difficulty}" endless="${!!d.MapSettings.endless}" />\n  <Audio muted="${!!d.Audio.muted}" />\n  <Towers>\n${t}\n  </Towers>\n  <timestamp>${Date.now()}</timestamp>\n</kaffekatten>`; }
      function fromXML(text,d){ const parser=new DOMParser(); const doc=parser.parseFromString(text,'application/xml'); if(doc.querySelector('parsererror')) return null; d=ensure(d); const get=s=>doc.querySelector(s); const adminEl=get('kaffekatten > Admin'); if(adminEl){ const sm=parseInt(adminEl.getAttribute('startMoney')); const sl=parseInt(adminEl.getAttribute('startLives')); if(!isNaN(sm)) d.Admin.startMoney=sm; if(!isNaN(sl)) d.Admin.startLives=sl; const upg=get('kaffekatten > Admin > upgCost'); if(upg){ const dd=parseInt(upg.getAttribute('dmg')); const rr=parseInt(upg.getAttribute('range')); const rt=parseInt(upg.getAttribute('rate')); if(!isNaN(dd)) d.Admin.upgCost.dmg=dd; if(!isNaN(rr)) d.Admin.upgCost.range=rr; if(!isNaN(rt)) d.Admin.upgCost.rate=rt; } } const setEl=get('kaffekatten > Settings'); if(setEl){ const ms=parseFloat(setEl.getAttribute('maxSpeed')); const bm=setEl.getAttribute('buildMode'); if(!isNaN(ms)) d.Settings.maxSpeed=ms; if(bm) d.Settings.buildMode=bm; } const visEl=get('kaffekatten > Visuals'); if(visEl){ d.Visuals.showGrid = visEl.getAttribute('showGrid')==='true'; const pw=parseInt(visEl.getAttribute('pathWidth')); if(!isNaN(pw)) d.Visuals.pathWidth=pw; } const mapEl=get('kaffekatten > Map'); if(mapEl){ const pr=mapEl.getAttribute('preset'); const df=parseInt(mapEl.getAttribute('difficulty')); const en=mapEl.getAttribute('endless')==='true'; if(pr) d.MapSettings.preset=pr; if(!isNaN(df)) d.MapSettings.difficulty=df; d.MapSettings.endless=en; } const audEl=get('kaffekatten > Audio'); if(audEl){ d.Audio.muted = audEl.getAttribute('muted')==='true'; } const towers=doc.querySelectorAll('kaffekatten > Towers > Tower'); towers.forEach(el=>{ const id=el.getAttribute('id'); if(!id) return; const ni=n=>{ const v=parseFloat(el.getAttribute(n)); return isNaN(v)?undefined:v; }; const str=n=>el.getAttribute(n); d.TOWER_TYPES[id]={ id, label:str('label')||id, cost:ni('cost')??50, range:ni('range')??80, dmg:ni('dmg')??5, fireRate:ni('fireRate')??1, color:str('color')||'#ccc', sellFactor:ni('sellFactor')??0.7, aoe:ni('aoe'), slow:ni('slow'), slowTime:ni('slowTime') }; }); return d; }
      function load(){ try{ return JSON.parse(localStorage.getItem(KEY)||'{}')||{}; }catch(e){ return {}; } }
      function save(d){ try{ d.ts=Date.now(); localStorage.setItem(KEY, JSON.stringify(d)); return true; }catch(e){ return false; } }

      function bind(){
        const btnExp=document.getElementById('btnExportXML');
        const btnImp=document.getElementById('btnImportXML');
        const file=document.getElementById('xmlFile');
        btnExp && btnExp.addEventListener('click',()=>{ const xml=toXML(load()); const blob=new Blob([xml],{type:'application/xml'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='kaffekatten-settings.xml'; document.body.appendChild(a); a.click(); setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); },0); });
        btnImp && btnImp.addEventListener('click',()=> file && file.click());
        file && file.addEventListener('change',()=>{ const f=file.files && file.files[0]; if(!f) return; const rdr=new FileReader(); rdr.onload=()=>{ const txt=String(rdr.result||''); const d=fromXML(txt, load()); if(d){ save(d); alert('XML importerat.'); } else alert('Ogiltig XML.'); }; rdr.readAsText(f); });
      }
      if(document.readyState==='loading') document.addEventListener('DOMContentLoaded', bind); else bind();
    })();
  </script>
  <script>
    // Quick accent palette chips (optional)
    (function(){
      function bind(){
        var host = document.getElementById('paletteChips'); if(!host) return;
        var colors = ['#2d6','#3b82f6','#e91e63','#f59e0b','#10b981','#00e5ff'];
        host.innerHTML = '';
        colors.forEach(function(col){
          var b=document.createElement('button'); b.type='button'; b.textContent=' '; b.style.width='28px'; b.style.height='28px'; b.style.borderRadius='6px'; b.style.border='1px solid #333'; b.style.background=col; b.style.cursor='pointer'; b.title=col; b.style.marginRight='6px';
          b.onclick=function(){ try{ var KEY='td-settings-v1'; var data={}; try{ data=JSON.parse(localStorage.getItem(KEY)||'{}')||{}; }catch(_e){ data={}; } data.Visuals = { ...(data.Visuals||{}), _accent: col, theme: 'custom' }; data.ts=Date.now(); localStorage.setItem(KEY, JSON.stringify(data)); alert('Accent uppdaterad. Starta spelet fÃ¶r att se Ã¤ndringen.'); }catch(_e){} };
          host.appendChild(b);
        });
      }
      if(document.readyState==='loading') document.addEventListener('DOMContentLoaded', bind); else bind();
    })();
  </script>
</head>
<body>
  <div class="wrap">
    <div class="hdr"><div class="title">Kaffekatten TD</div><div class="small">Alpha</div></div>
    <div class="grid">
      <div class="card">
        <label>Karta</label>
  <select id="mapPreset"><!-- Options populated by JS --></select>
        <div class="row">
          <div>
            <label>SvÃ¥righet (1â€“5)</label>
            <input id="difficulty" type="number" min="1" max="5" value="1" />
          </div>
          <div>
            <label>&nbsp;</label>
            <label style="display:flex;gap:8px;align-items:center"><input id="endless" type="checkbox" /> Endless</label>
          </div>
        </div>
        <label>Byggâ€‘lÃ¤ge</label>
        <select id="buildMode">
          <option value="paint">Paint</option>
          <option value="single">Single</option>
        </select>
        <div class="row" style="margin-top:8px">
          <label style="display:flex;gap:8px;align-items:center"><input id="colorblind" type="checkbox" /> HÃ¶gkontrast (fÃ¤rgblind)</label>
          <label style="display:flex;gap:8px;align-items:center"><input id="reducedMotion" type="checkbox" /> Minska rÃ¶relse</label>
        </div>
    <div class="small" style="margin-top:8px">Snabbt val: accent</div>
    <div id="paletteChips" class="row-btns" style="margin-top:4px"></div>
        <a id="btnStart" class="btn" href="./SPEL.HTML">Starta spelet</a>
        <div class="links"><a href="./ADMIN.html">Admin</a></div>
        <div class="row-btns">
          <button id="btnExportXML" type="button">Exportera XML</button>
          <button id="btnImportXML" type="button">Importera XML</button>
          <input id="xmlFile" type="file" accept=".xml,application/xml" style="display:none" />
        </div>
        <div class="small" style="margin-top:8px">Tips: NÃ¤r spelet startat kan du hÃ¥lla musen Ã¶ver knapparna fÃ¶r att se deras snabbkommandon.</div>
      </div>
      <div class="card preview">
        <div class="small" style="margin-bottom:6px">FÃ¶rhandsvisning</div>
        <canvas id="mapPrev" width="480" height="300"></canvas>
      </div>
    </div>
  </div>
</body>
</html>
